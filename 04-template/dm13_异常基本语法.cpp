//
// Created by YANHAI on 2019/12/15.
//

/**
 * 基本语法
 *  1.发生异常之后，是跨函数的
 *  2.接收异常以后，可以不处理，再抛出异常
 *  3.catch异常的时候，按照类型进行catch
 *  4.异常捕捉严格按照类型匹配，不允许隐式类型转换
 *  5.异常机制与函数机制互不干涉，但捕捉的方式是基于类型匹配，
 *    捕捉相当于函数返回类型的匹配，而不是函数参数的匹配，所以捕捉不用考虑
 *    一个抛掷中的多种数据类型匹配问题
 *
 * 基本思想
 *  1.C++的异常处理机制使得 异常的引发 和异常的处理不必在同一个函数中，
 *    这样底层的函数可以着重解决具体问题，而不必过多的考虑异常的处理，
 *    上层调用者可以再适当的位置设计 对不同类型异常的处理；
 *  2.异常是专门针对抽象编程中的一系列错误处理的。c++中不能借助函数机制，
 *    因为栈结构的本质是先进先出，依次访问，无法进行跳跃，但错误处理的特征
 *    却是遇到错误信息就想要转到若干级之上进行重新尝试。
 *  3.异常超脱于函数机制，决定了其对函数的跨越式回跳；
 *  4.异常跨越函数。
 */

#include <iostream>

using namespace std;

void divide(int x, int y)
{
    if (y == 0) {
        throw x;    // 抛出 int类型 异常
    }
    cout << x << "/" << y << "=" << x / y << endl;
}

int main()
{
    try {
        divide(10, 2);
        divide(100, 0);
    } catch (int e) {
        cout << e << "被除零" << endl;
    } catch (...) {
        cout << "未知异常" << endl;
    }

    // 捕获异常时，严格按照类型进行匹配
    {
        try {
            throw 'A';
        } catch (int e) {
            cout << "捕获int类型异常" << endl;
        }
        catch (...) {
            cout << "未知异常" << endl;
        }
    }
    return 0;
}
